.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_SKEY 3ssl"
.TH EVP_SKEY 3ssl "2025-10-01" "3.6.0" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_SKEY, EVP_SKEY_generate, EVP_SKEY_import, EVP_SKEY_import_raw_key,
EVP_SKEY_import_SKEYMGMT, EVP_SKEY_up_ref, EVP_SKEY_export,
EVP_SKEY_get0_raw_key, EVP_SKEY_get0_key_id, EVP_SKEY_get0_skeymgmt_name,
EVP_SKEY_get0_provider_name, EVP_SKEY_free, EVP_SKEY_is_a, EVP_SKEY_to_provider
\&\- opaque symmetric key allocation and handling functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& typedef evp_skey_st EVP_SKEY;
\&
\& EVP_SKEY *EVP_SKEY_generate(OSSL_LIB_CTX *libctx, const char *skeymgmtname,
\&                             const char *propquery, const OSSL_PARAM *params);
\& EVP_SKEY *EVP_SKEY_import(OSSL_LIB_CTX *libctx, const char *skeymgmtname,
\&                           const char *propquery,
\&                           int selection, const OSSL_PARAM *params);
\& EVP_SKEY *EVP_SKEY_import_raw_key(OSSL_LIB_CTX *libctx, const char *skeymgmtname,
\&                                   unsigned char *key, size_t *len,
\&                                   const char *propquery);
\& EVP_SKEY *EVP_SKEY_import_SKEYMGMT(OSSL_LIB_CTX *libctx, EVP_SKEYMGMT *skeymgmt,
\&                                    int selection, const OSSL_PARAM *params);
\& int EVP_SKEY_export(const EVP_SKEY *skey, int selection,
\&                     OSSL_CALLBACK *export_cb, void *export_cbarg);
\& int EVP_SKEY_get0_raw_key(const EVP_SKEY *skey, const unsigned char **key,
\&                          size_t *len);
\& const char *EVP_SKEY_get0_key_id(const EVP_SKEY *skey);
\&
\& const char *EVP_SKEY_get0_skeymgmt_name(const EVP_SKEY *skey);
\& const char *EVP_SKEY_get0_provider_name(const EVP_SKEY *skey);
\&
\& int EVP_SKEY_up_ref(EVP_SKEY *key);
\& void EVP_SKEY_free(EVP_SKEY *key);
\& int EVP_SKEY_is_a(const EVP_SKEY *skey, const char *name);
\& EVP_SKEY *EVP_SKEY_to_provider(EVP_SKEY *skey, OSSL_LIB_CTX *libctx,
\&                                OSSL_PROVIDER *prov, const char *propquery);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1EVP_SKEY\s0\fR is a generic structure to hold symmetric keys as opaque objects.
The keys themselves are often referred to as the \*(L"internal key\*(R", and are handled by
providers using \s-1\fBEVP_SKEYMGMT\s0\fR\|(3).
.PP
Conceptually, an \fB\s-1EVP_SKEY\s0\fR internal key may hold a symmetric key, and along
with those, key parameters if the key type requires them.
.PP
The \fBEVP_SKEY_generate()\fR functions creates a new \fB\s-1EVP_SKEY\s0\fR object and
initializes it according to the \fBparams\fR argument.
.PP
The \fBEVP_SKEY_import()\fR function allocates an empty \fB\s-1EVP_SKEY\s0\fR structure
which is used by OpenSSL to store symmetric keys, assigns the
\&\fB\s-1EVP_SKEYMGMT\s0\fR object associated with the key, and initializes the object from
the \fBparams\fR argument.
.PP
The \fBEVP_SKEY_import_raw_key()\fR function is a helper that creates an \fB\s-1EVP_SKEY\s0\fR object
containing the raw byte representation of the symmetric keys.
.PP
The \fBEVP_SKEY_import_SKEYMGMT()\fR function is a helper that creates an \fB\s-1EVP_SKEY\s0\fR
object containing the representation of the symmetric keys specific to the
particular \fB\s-1EVP_SKEYMGMT\s0\fR.
.PP
The \fBEVP_SKEY_export()\fR function extracts values from a key \fIskey\fR using the
\&\fIselection\fR.  \fIselection\fR is described below. It uses a callback \fIexport_cb\fR
that gets passed the value of \fIexport_cbarg\fR.  See \fBopenssl\-core.h\fR\|(7) for
more information about the callback. Note that the \s-1\fBOSSL_PARAM\s0\fR\|(3) array that
is passed to the callback is not persistent after the callback returns.
.PP
The \fBEVP_SKEY_get0_raw_key()\fR returns a pointer to a raw key bytes to the passed
address and sets the key len. The returned address is managed by the internal
key management and shouldn't be freed explicitly.  The operation can fail when
the underlying key management doesn't support export of the secret key.
.PP
The \fBEVP_SKEY_get0_key_id()\fR returns a NUL-terminated string providing some
human-readable identifier of the key if provided by the underlying key
management. The pointer becomes invalid after freeing the \s-1EVP_SKEY\s0 object.
.PP
The \fBEVP_SKEY_get0_skeymgmt_name()\fR and \fBEVP_SKEY_get0_provider_name()\fR return the
names of the associated \s-1EVP_SKEYMGMT\s0 object and its provider correspondingly.
.PP
\&\fBEVP_SKEY_up_ref()\fR increments the reference count of \fIkey\fR.
.PP
\&\fBEVP_SKEY_free()\fR decrements the reference count of \fIkey\fR and, if the reference
count is zero, frees it. If \fIkey\fR is \s-1NULL,\s0 nothing is done.
.PP
\&\fBEVP_SKEY_is_a()\fR checks if the key type of \fIskey\fR is \fIname\fR.
.PP
\&\fBEVP_SKEY_to_provider()\fR simplifies the task of importing a \fIskey\fR into a
different provider identified by \fIprov\fR. If \fIprov\fR is \s-1NULL,\s0 the default
provider for the key type identified via \fIskey\fR is used.
.SS "Selections"
.IX Subsection "Selections"
The following constants can be used for \fIselection\fR:
.IP "\fB\s-1OSSL_SKEYMGMT_SELECT_SECRET_KEY\s0\fR" 4
.IX Item "OSSL_SKEYMGMT_SELECT_SECRET_KEY"
Only the raw key representation will be selected.
.IP "\fB\s-1OSSL_SKEYMGMT_SELECT_PARAMETERS\s0\fR" 4
.IX Item "OSSL_SKEYMGMT_SELECT_PARAMETERS"
Only the key parameters will be selected. This includes optional key
parameters.
.IP "\fB\s-1OSSL_SKEYMGMT_SELECT_ALL\s0\fR" 4
.IX Item "OSSL_SKEYMGMT_SELECT_ALL"
All parameters will be selected.
.SH "NOTES"
.IX Header "NOTES"
The \fB\s-1EVP_SKEY\s0\fR structure is used by various OpenSSL functions which require a
general symmetric key without reference to any particular algorithm.
.PP
The \fBEVP_SKEY_to_provider()\fR function will fail and return \s-1NULL\s0 if the origin
key \fIskey\fR cannot be exported from its provider.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBEVP_SKEY_generate()\fR, \fBEVP_SKEY_import()\fR, \fBEVP_SKEY_import_raw_key()\fR, and
\&\fBEVP_SKEY_import_SKEYMGMT()\fR return either the newly allocated \fB\s-1EVP_SKEY\s0\fR
structure or \s-1NULL\s0 if an error occurred.
.PP
\&\fBEVP_SKEY_get0_key_id()\fR returns either a valid pointer or \s-1NULL.\s0
.PP
\&\fBEVP_SKEY_up_ref()\fR returns 1 for success and 0 on failure.
.PP
\&\fBEVP_SKEY_export()\fR and \fBEVP_SKEY_get0_raw_key()\fR return 1 for success and 0 on failure.
.PP
\&\fBEVP_SKEY_get0_skeymgmt_name()\fR and \fBEVP_SKEY_get0_provider_name()\fR return the
names of the associated \s-1EVP_SKEYMGMT\s0 object and its provider correspondigly.
.PP
\&\fBEVP_SKEY_is_a()\fR returns 1 if \fIskey\fR has the key type \fIname\fR,
otherwise 0.
.PP
\&\fBEVP_SKEY_to_provider()\fR returns a new \fB\s-1EVP_SKEY\s0\fR suitable for operations with
the \fIprov\fR provider or \s-1NULL\s0 in case of failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1\fBEVP_SKEYMGMT\s0\fR\|(3), \fBprovider\fR\|(7), \s-1\fBOSSL_PARAM\s0\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
The \fB\s-1EVP_SKEY\s0\fR \s-1API\s0 and functions \fBEVP_SKEY_export()\fR,
\&\fBEVP_SKEY_free()\fR, \fBEVP_SKEY_get0_raw_key()\fR, \fBEVP_SKEY_import()\fR,
\&\fBEVP_SKEY_import_raw_key()\fR, \fBEVP_SKEY_up_ref()\fR, \fBEVP_SKEY_generate()\fR,
\&\fBEVP_SKEY_get0_key_id()\fR, \fBEVP_SKEY_get0_provider_name()\fR,
\&\fBEVP_SKEY_get0_skeymgmt_name()\fR, \fBEVP_SKEY_is_a()\fR, \fBEVP_SKEY_to_provider()\fR
were introduced in OpenSSL 3.5.
.PP
The \fBEVP_SKEY_import_SKEYMGMT()\fR function was introduced in OpenSSL 4.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
