.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_LOAD_U16_LE 3ssl"
.TH OPENSSL_LOAD_U16_LE 3ssl "2025-10-01" "3.6.0" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_load_u16_le, OPENSSL_load_u16_be, OPENSSL_load_u32_le,
OPENSSL_load_u32_be, OPENSSL_load_u64_le, OPENSSL_load_u64_be,
OPENSSL_store_u16_le, OPENSSL_store_u16_be,
OPENSSL_store_u32_le, OPENSSL_store_u32_be,
OPENSSL_store_u64_le, OPENSSL_store_u64_be \-
Read and write unsigned 16, 32 and 64\-bit integers in a specific byte order
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include <openssl/byteorder.h>
\&
\&    static ossl_inline unsigned char *OPENSSL_store_u16_le(
\&        unsigned char *out, uint16_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u16_be(
\&        unsigned char *out, uint16_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u32_le(
\&        unsigned char *out, uint32_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u32_be(
\&        unsigned char *out, uint32_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u64_le(
\&        unsigned char *out, uint64_t val);
\&    static ossl_inline unsigned char *OPENSSL_store_u64_be(
\&        unsigned char *out, uint64_t val);
\&    static ossl_inline const unsigned char *OPENSSL_load_u16_le(
\&        uint16_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u16_be(
\&        uint16_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u32_le(
\&        uint32_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u32_be(
\&        uint32_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u64_le(
\&        uint64_t *val, const unsigned char *in);
\&    static ossl_inline const unsigned char *OPENSSL_load_u64_be(
\&        uint64_t *val, const unsigned char *in);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions read and write 16, 32 and 64 bit unsigned integers in a
specified byte order.
The \f(CW\*(C`_be\*(C'\fR functions use big-endian byte order, while the \f(CW\*(C`_le\*(C'\fR functions use
little-endian byte order.
They're implemented directly in the header file, and declared static.  When the
compiler supports inline functions, they're also declared inline.
An optimising compiler will often convert these to just one or two machine
instructions: a load or store with a possible byte swap.
.PP
The \f(CW\*(C`load\*(C'\fR functions write the decoded integer value at the address pointed to
by \fIval\fR, which must be a valid (possibly suitably aligned) address of an
object of the appropriate type.
The \f(CW\*(C`store\*(C'\fR functions write the encoding of \fIval\fR at the address pointed to
by \fIout\fR.
.PP
For convenience, these functions return the updated input or output pointer,
making it easy to continue reading or writing more data at the next memory
location.
.PP
No bounds checks are performed, the caller is responsible for making sure that
the input or output buffers are sufficiently large for the requested read or
write.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
All these functions return the next memory address following the last byte
written or read.
.SH "HISTORY"
.IX Header "HISTORY"
These functions were added in OpenSSL 3.5.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
